
proto enum

def enum/map(cb)
  let res = []
  for x in @make_iter()
    res.push!(cb(x))
  end

  res
end

def enum/reduce(cb, first)
  let acc = first
  for x in @make_iter()
    acc = cb(acc, x)
  end

  acc
end

def enum/filter(cb)
  let res = []
  for x in @make_iter()
    if cb(x)
      res.push!(x)
    end
  end

  res
end

def enum/take(n)
  let iter = @make_iter()
  let next = iter.next()
  let res = []
  let i = 0

  while next[0] == :ok and i < n
    res.push!(next[1])
    i = i + 1
    next = iter.next()
  end

  res
end

def enum/take_while(cb)
  let iter = @make_iter()
  let next = iter.next()
  let res = []
  while next[0] == :ok and cb(next[1])
    res.push!(next[1])
    next = iter.next()
  end

  res
end

def enum/drop(n)
  let iter = @make_iter()
  let i = 0
  let next = iter.next()

  while next[0] == :ok and i < n
    i = i + 1
    next = iter.next()
  end

  let res = []
  while next[0] == :ok
    res.push!(next[1])
    next = iter.next()
  end

  res
end

def enum/drop_while(cb)
  let iter = @make_iter()
  let next = iter.next()
  while next[0] == :ok and cb(next[1])
    next = iter.next()
  end

  let res = []
  while next[0] == :ok
    res.push!(next[1])
    next = iter.next()
  end

  res
end

def enum/last(n)
  let res = []
  for x in @make_iter()
    res.push!(x)
  end

  res.drop(res.len() - n)
end

def enum/includes?(x)
  @filter(\z => z == x).len() > 0
end

def enum/list()
  let res = []
  for x in @make_iter()
    res.push!(x)
  end

  res
end

def enum/len()
  let i = 0
  for x in @make_iter()
    i = i + 1
  end

  i
end

def enum/sum()
  @reduce(\acc, x => acc + x, 0)
end

def enum/product()
  @reduce(\acc, x => acc * x, 1)
end

def enum/reverse()
  let res = []
  for x in @make_iter()
    res.push_front!(x)
  end

  res
end

def enum/partition(is_left_cb)
  let l = []
  let r = []
  for x in @make_iter()
    if (is_left_cb(x))
      l.push!(x)
    else
      r.push!(x)
    end
  end

  [l, r]
end

def enum/min(n)
  this.sort().take(n)
end

def enum/max(n)
  this.sort().last(n)
end

def enum/batch(n)
  'TODO: error if n < 1'

  let res = []
  let batch = []
  let i = 0

  for x in @make_iter()
    if i == n
      res.push!(batch)
      batch = []
      i = 0
    end

    batch.push!(x)
    i = i + 1
  end

  if batch.len() > 0
    res.push!(batch)
  end

  res
end


proto enum

def enum/map(cb)
  let res = []
  for x in @make_iter()
    res.push!(cb(x))
  end

  res
end

def enum/reduce(cb, first)
  let acc = first
  for x in @make_iter()
    acc = cb(acc, x)
  end

  acc
end

def enum/filter(cb)
  let res = []
  for x in @make_iter()
    if cb(x)
      res.push!(x)
    end
  end

  res
end

def enum/take(n)
  let iter = @make_iter()
  let next = iter.next()
  let res = []
  let i = 0

  while next[0] == :ok and i < n
    res.push!(next[1])
    i = i + 1
    next = iter.next()
  end

  res
end

def enum/take_while(cb)
  let iter = @make_iter()
  let next = iter.next()
  let res = []
  while next[0] == :ok and cb(next[1])
    res.push!(next[1])
    next = iter.next()
  end

  res
end

def enum/drop(n)
  let iter = @make_iter()
  let i = 0
  let next = iter.next()

  while next[0] == :ok and i < n
    i = i + 1
    next = iter.next()
  end

  let res = []
  while next[0] == :ok
    res.push!(next[1])
    next = iter.next()
  end

  res
end

def enum/drop_while(cb)
  let iter = @make_iter()
  let next = iter.next()
  while next[0] == :ok and cb(next[1])
    next = iter.next()
  end

  let res = []
  while next[0] == :ok
    res.push!(next[1])
    next = iter.next()
  end

  res
end

def enum/last(n)
  let res = []
  for x in @make_iter()
    res.push!(x)
  end

  res.drop(res.len() - n)
end

def enum/includes?(x)
  @filter(\z => z == x).len() > 0
end

def enum/list()
  let res = []
  for x in @make_iter()
    res.push!(x)
  end

  res
end

def enum/len()
  let i = 0
  for x in @make_iter()
    i = i + 1
  end

  i
end

def enum/sum()
  @reduce(\acc, x => acc + x, 0)
end

def enum/product()
  @reduce(\acc, x => acc * x, 1)
end

